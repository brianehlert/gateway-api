# JWT Policy

## TLDR

This document is not intended to describe how a proxy implements JWT handling behavior, there is an RFC that addresses that.
Rather, this document is to form a common understanding or JWT use cases as it relates to configuring and handling JWTs as par of a workflow as it relates to a Gateway and establish a framework from which to build the common parts of the Policy.

## Goals

- Define how JWT is used to form a common understanding and establish a common language
- Identify unique use cases for JWT with proxies
- Propose some properties to form the basis for discussion

## Non-Goals

- Define how proxies implement the JWT standards

## What is a JWT

A [JSON web token](https://www.rfc-editor.org/rfc/rfc7519) is a common pattern of presenting authorization data (claims) between a front end or client system and a back end.
A JWT by itself it is only one piece of the [authentication triad](https://csrc.nist.gov/glossary/term/Multi_Factor_Authentication#:~:text=The%20three%20authentication%20factors), which is "something you have".  We will assume that some other process satisfied "something you are" and "something you know".  And thus the JWT is generally considered the result of some type of authentication or formation of a trust.

JWT's can be encrypted, have methods for validation, can contain a variety of claims, and be used in gate keeping (validation) and authorization (claims matching) workflows.

## How is a JWT used

In practice a JWT is presented to an authorization layer to make a decision of whether or not to grant access to a specific hostname or application path (backend service) or also possibly used by the backend service to decide if specific secured data can be presented.
This bring forth a set of common workflows which in turn present the use cases. In this example we will walk through the life of an encrypted JWT (though not all JWTs are encrypted)

- client obtains a JWT
- client presents the JWT with the request to a Gateway
- the Gateway decrypts the JWT and validates it
- now that the JWT is proven valid it is implicitly trusted and the request processing continues

At this point a number of and/or paths can take place, most commonly a combination of the following happens:

- the token content is tested for the existence of some claim property or value
- claim values may be extracted and saved as header value(s) to the request
- the entire token or a sub-set of claims may be forwarded directly to backend services for evaluation

## Persona(s)

The Personas that can be involved in managing JWT Policy can be:

- platform / cluster operations
- application developer / admins
- user account manager
- security operations

## Prior related art

Here are some samples of JWT implementations in a similar problem space.  Each implementation differs in terminology and implementation.

- NGINX Ingress Controller:

  - [](https://docs.nginx.com/nginx-ingress-controller/configuration/policy-resource/#jwt-using-local-kubernetes-secret)
  - [](https://docs.nginx.com/nginx-ingress-controller/configuration/policy-resource/#jwt-using-jwks-from-remote-location)
  
- Kong:

  - [https://docs.konghq.com/hub/kong-inc/jwt/configuration/](https://docs.konghq.com/hub/kong-inc/jwt/configuration/)

- Envoy Gateway:

  - [https://gateway.envoyproxy.io/v0.4.0/api/extension_types.html#jwtauthenticationfilterprovider](https://gateway.envoyproxy.io/v0.4.0/api/extension_types.html#jwtauthenticationfilterprovider)

- Istio:

  - [https://istio.io/latest/docs/tasks/security/authorization/authz-jwt/](https://istio.io/latest/docs/tasks/security/authorization/authz-jwt/)

## Properties of a JWT Validation Policy

The validation policy is two fold, it establishes the relationship with the Token and how to validate it.
According to [https://datatracker.ietf.org/doc/html/rfc7519#section-4.1](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1) claims cannot be assumed mandatory.  At a minimum a claim should be able to be validated following the process outlined here which only requires a method to decrypt if necessary: [https://datatracker.ietf.org/doc/html/rfc7519#section-7.2](https://datatracker.ietf.org/doc/html/rfc7519#section-7.2)

The statements made above point to the primary points of divergence between the JWT validation implementations in the prior art section.

Some very high level proposed properties to open the conversation based on comparing the implementations and reviewing the RFC.

- name / realm (required) - the name / realm of the JWT, this is commonly a string representing a specific application.  It is seen used in response and log messages.
- secret (optional) - The name of the Kubernetes secret that stores the JWK.
- jwksURI (optional) - The remote URI where the request will be sent to retrieve JSON Web Key set
- keyCache (extension) - Enables in-memory caching of JWKS (JSON Web Key Sets) that are obtained from the jwksURI and sets a valid time for expiration.
- token (extension) - The token specifies a variable that contains the JSON Web Token in the request. By default the JWT is passed in the Authorization header as a Bearer Token. JWT may be also passed as a cookie or a part of a query string, for example: $cookie_auth_token. Accepted variables are $http_, $arg_, $cookie_.

Example patterns:
name
secret

name
jwksURI

name
token
jwksURI
keycache

## Properties of a JWT Claims (authorization) Policy

- token - the token that needs to be evaluated (this is the result of the validation Policy or an OIDC workflow)
- claimsMatch - an array of claim properties (exists, not exists) or match value that must match to allow the request to proceed.

Processing claims, such as extracting a value from the token and setting it as a header for a backend should not be part of a policy.
